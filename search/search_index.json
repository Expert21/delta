{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>Documentation for the Delta Operating System and it's constituent parts.</p>"},{"location":"boot/protocol/","title":"Delta Boot Protocol","text":""},{"location":"boot/protocol/#overview","title":"Overview","text":"<p>The DB protocol defines:</p> <ol> <li>DB Request Header \u2014 Embedded in the kernel binary, tells the bootloader what's needed</li> <li>DB Boot Info \u2014 Passed to the kernel at boot, contains system information as tags</li> </ol> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    KERNEL BINARY                             \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502  DB Request Header (magic + version + flags)           \u2502  \u2502\n\u2502  \u2502  Request Tags: what the kernel wants from bootloader   \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n                           \u25bc bootloader reads &amp; prepares\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    DB BOOT INFO                              \u2502\n\u2502  Passed to kernel entry point (pointer in arch-defined reg)  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502  Info Header                                           \u2502  \u2502\n\u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502\n\u2502  \u2502  Tag: Memory Map                                       \u2502  \u2502\n\u2502  \u2502  Tag: Framebuffer                                      \u2502  \u2502\n\u2502  \u2502  Tag: Command Line                                     \u2502  \u2502\n\u2502  \u2502  Tag: ...                                              \u2502  \u2502\n\u2502  \u2502  Tag: End                                              \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"boot/protocol/#data-types","title":"Data Types","text":"<p>All multi-byte integers are little-endian=</p> Type Size Description <code>u8</code> 1 byte Unsigned 8-bit <code>u16</code> 2 bytes Unsigned 16-bit LE <code>u32</code> 4 bytes Unsigned 32-bit LE <code>u64</code> 8 bytes Unsigned 64-bit LE"},{"location":"boot/protocol/#part-1-db-request-header","title":"Part 1: DB Request Header","text":"<p>The kernel embeds this header to identify itself as DB-compliant and request features.</p>"},{"location":"boot/protocol/#location","title":"Location","text":"<p>The bootloader scans the first 32 KiB of the kernel binary for the magic number, Header must be 8-byte aligned.</p>"},{"location":"boot/protocol/#structure","title":"Structure","text":"<pre><code>struct db_request_header {\n    u32 magic;          // 0x44420001 ('D' 'B' 0x00 0x01)\n    u32 checksum;       // CRC32 of header + tags (with this field as 0)\n    u16 version;        // Protocol version (0x0001 for v0.1)\n    u16 header_size;    // Size of this header + all request tags\n    u32 flags;          // Request flags (see below)\n    u32 entry_point;    // Offset (not address!) of kernel entry point\n                        // Relative to start of loaded kernel image\n                        // Use 0xFFFFFFFF if bootloader should use format-specific entry\n};\n// Followed by request tags (until header_size is reached)\n</code></pre> <p>Magic breakdown: <code>0x44420001</code> - <code>0x44</code> = 'D' - <code>0x42</code> = 'B' - <code>0x00</code> = null separator - <code>0x01</code> = format version</p>"},{"location":"boot/protocol/#checksum","title":"Checksum","text":"<p>The <code>checksum</code> field contains a CRC32 (polynomial <code>0xEDB88320</code>) computed over the entire header including request tags, with the <code>checksum</code> field itself treated as zero during computation.</p> <p>To compute: 1. Set <code>checksum</code> to 0 2. Calculate CRC32 over bytes <code>[0, header_size)</code> 3. Store result in <code>checksum</code></p> <p>To verify: 1. Save <code>checksum</code> value 2. Set <code>checksum</code> to 0 3. Calculate CRC32 over bytes <code>[0, header_size)</code> 4. Compare with saved value</p>"},{"location":"boot/protocol/#request-flags","title":"Request Flags","text":"Bit Name Description 0 <code>DB_REQ_FRAMEBUFFER</code> Kernel requests framebuffer info 1 <code>DB_REQ_MEMORY_MAP</code> Kernel requests memory map (should always be set) 2 <code>DB_REQ_MODULES</code> Kernel supports loaded modules 3 <code>DB_REQ_ACPI</code> Kernel requests ACPI RSDP pointer 4 <code>DB_REQ_CMDLINE</code> Kernel accepts command line 5 <code>DB_REQ_SMP</code> Kernel requests SMP info (CPU count, etc.) 6 <code>DB_REQ_INITRD</code> Kernel requests initial ramdisk 7 <code>DB_REQ_HAS_TAGS</code> Request tags follow the header 8-31 Reserved Must be zero"},{"location":"boot/protocol/#flags-and-tags-precedence","title":"Flags and Tags Precedence","text":"<ul> <li>Flag set, no tag: Bootloader provides the feature with default values</li> <li>Flag set, tag present: Bootloader uses tag values (tag refines the request)</li> <li>Flag not set, tag present: Tag is ignored (flag must be set to enable feature)</li> </ul>"},{"location":"boot/protocol/#part-1b-request-tags","title":"Part 1b: Request Tags","text":"<p>Request tags allow the kernel to specify detailed requirements beyond simple flags. They immediately follow the request header and are included in <code>header_size</code>.</p>"},{"location":"boot/protocol/#request-tag-structure","title":"Request Tag Structure","text":"<pre><code>struct db_request_tag {\n    u16 type;           // Request tag type\n    u16 flags;          // Tag-specific flags\n    u32 size;           // Total size of this tag (including header)\n    // Tag-specific data follows\n};\n</code></pre> <p>Alignment: Each request tag starts at a 4-byte aligned offset from header start</p>"},{"location":"boot/protocol/#request-tag-types","title":"Request Tag Types","text":"Type Name Description 0x0000 <code>DB_RTAG_END</code> End of request tag list 0x0001 <code>DB_RTAG_FRAMEBUFFER_PREF</code> Preferred framebuffer settings 0x0002 <code>DB_RTAG_MIN_MEMORY</code> Minimum memory requirement 0x0003 <code>DB_RTAG_LOAD_ADDRESS</code> Preferred/required load address 0x0004 <code>DB_RTAG_STACK_SIZE</code> Requested initial stack size 0x0005 <code>DB_RTAG_ARCH_FEATURES</code> Architecture-specific feature requests"},{"location":"boot/protocol/#db_rtag_framebuffer_pref-0x0001","title":"DB_RTAG_FRAMEBUFFER_PREF (0x0001)","text":"<p>Specify preferred framebuffer resolution and pixel format.</p> <pre><code>struct db_rtag_framebuffer_pref {\n    u16 type;           // 0x0001\n    u16 flags;          // Bit 0: required (fail if unavailable)\n    u32 size;           // 24\n    u32 min_width;      // Minimum acceptable width (0 = any)\n    u32 min_height;     // Minimum acceptable height (0 = any)\n    u32 preferred_width;  // Preferred width (0 = any)\n    u32 preferred_height; // Preferred height (0 = any)\n    u8  min_bpp;        // Minimum bits per pixel (0 = any)\n    u8  preferred_bpp;  // Preferred bpp (0 = any)\n    u8  padding[2];\n};\n</code></pre>"},{"location":"boot/protocol/#db_rtag_min_memory-0x0002","title":"DB_RTAG_MIN_MEMORY (0x0002)","text":"<p>Specify minimum RAM requirement.</p> <pre><code>struct db_rtag_min_memory {\n    u16 type;           // 0x0002\n    u16 flags;          // 0\n    u32 size;           // 16\n    u64 min_bytes;      // Minimum usable RAM required\n};\n</code></pre>"},{"location":"boot/protocol/#db_rtag_load_address-0x0003","title":"DB_RTAG_LOAD_ADDRESS (0x0003)","text":"<p>Request a specific load address (hint or requirement).</p> <pre><code>struct db_rtag_load_address {\n    u16 type;           // 0x0003\n    u16 flags;          // Bit 0: required (fail if unavailable)\n    u32 size;           // 24\n    u64 preferred_addr; // Preferred physical load address\n    u64 alignment;      // Required alignment (must be power of 2)\n};\n</code></pre>"},{"location":"boot/protocol/#db_rtag_stack_size-0x0004","title":"DB_RTAG_STACK_SIZE (0x0004)","text":"<p>Request initial kernel stack size.</p> <pre><code>struct db_rtag_stack_size {\n    u16 type;           // 0x0004\n    u16 flags;          // 0\n    u32 size;           // 16\n    u64 stack_size;     // Requested stack size in bytes (0 = bootloader default)\n};\n</code></pre>"},{"location":"boot/protocol/#part-2-db-boot-info","title":"Part 2: DB Boot Info","text":"<p>Prepared by the bootloader and passed to the kernel.</p>"},{"location":"boot/protocol/#passing-convention","title":"Passing Convention","text":"<p>The bootloader passes a pointer to <code>db_boot_info</code> in an architecture-defined register:</p> Architecture Register Notes x86 (32-bit) <code>EBX</code> Physical address x86_64 <code>RDI</code> Physical address (first arg) ARM32 <code>R0</code> Physical address AArch64 <code>X0</code> Physical address RISC-V <code>A0</code> Physical address"},{"location":"boot/protocol/#info-header-structure","title":"Info Header Structure","text":"<pre><code>struct db_boot_info {\n    u32 magic;          // 0x44424F4B ('D' 'B' 'O' 'K' \u2014 \"DB OK\")\n    u32 total_size;     // Total size of boot info including all tags\n    u32 version;        // Protocol version\n    u32 reserved;       // Must be zero\n};\n// Immediately followed by tags\n</code></pre>"},{"location":"boot/protocol/#part-3-tags","title":"Part 3: Tags","text":"<p>Tags are variable-length structures that follow the header.</p>"},{"location":"boot/protocol/#tag-structure","title":"Tag Structure","text":"<pre><code>struct db_tag {\n    u16 type;           // Tag type identifier\n    u16 flags;          // Tag-specific flags\n    u32 size;           // Total size of this tag (including header)\n    // Tag-specific data follows\n};\n</code></pre> <p>Alignment: Each tag starts at an 8-byte aligned address. Padding: Bootloader inserts padding bytes (value 0) between tags as needed.</p>"},{"location":"boot/protocol/#tag-types","title":"Tag Types","text":"Type Name Description 0x0000 <code>DB_TAG_END</code> End of tag list 0x0001 <code>DB_TAG_CMDLINE</code> Command line string 0x0002 <code>DB_TAG_MEMORY_MAP</code> System memory map 0x0003 <code>DB_TAG_FRAMEBUFFER</code> Framebuffer information 0x0004 <code>DB_TAG_MODULES</code> Loaded modules (generic) 0x0005 <code>DB_TAG_ACPI_RSDP</code> ACPI RSDP pointer 0x0006 <code>DB_TAG_SMP</code> SMP/CPU information 0x0007 <code>DB_TAG_BOOT_TIME</code> Boot timestamp 0x0008 <code>DB_TAG_BOOTLOADER</code> Bootloader name/version 0x0009 <code>DB_TAG_KERNEL_FILE</code> Original kernel file info 0x000A <code>DB_TAG_EFI_SYSTEM_TABLE</code> EFI System Table pointer (if UEFI) 0x000B <code>DB_TAG_INITRD</code> Initial ramdisk (initrd/initramfs) 0x8000+ Vendor-specific Reserved for custom extensions"},{"location":"boot/protocol/#tag-definitions","title":"Tag Definitions","text":""},{"location":"boot/protocol/#db_tag_end-0x0000","title":"DB_TAG_END (0x0000)","text":"<p>Marks the end of the tag list. Required.</p> <pre><code>struct db_tag_end {\n    u16 type;           // 0x0000\n    u16 flags;          // 0\n    u32 size;           // 8\n};\n</code></pre>"},{"location":"boot/protocol/#db_tag_cmdline-0x0001","title":"DB_TAG_CMDLINE (0x0001)","text":"<p>Null-terminated command line string.</p> <pre><code>struct db_tag_cmdline {\n    u16 type;           // 0x0001\n    u16 flags;          // 0\n    u32 size;           // 8 + string length + 1 (null terminator)\n    char cmdline[];     // Null-terminated UTF-8 string\n};\n</code></pre>"},{"location":"boot/protocol/#db_tag_memory_map-0x0002","title":"DB_TAG_MEMORY_MAP (0x0002)","text":"<p>Describes physical memory layout.</p> <pre><code>struct db_tag_memory_map {\n    u16 type;           // 0x0002\n    u16 flags;          // 0\n    u32 size;           // Total tag size\n    u32 entry_size;     // Size of each entry (for forward compat)\n    u32 entry_count;    // Number of entries\n    struct db_mmap_entry entries[];\n};\n\nstruct db_mmap_entry {\n    u64 base;           // Physical base address\n    u64 length;         // Length in bytes\n    u32 type;           // Memory type (see below)\n    u32 attributes;     // Additional attributes\n};\n</code></pre> <p>Memory Types:</p> Value Name Description 0 <code>DB_MEM_RESERVED</code> Reserved, do not use 1 <code>DB_MEM_USABLE</code> Free RAM, available for use 2 <code>DB_MEM_ACPI_RECLAIMABLE</code> ACPI tables, reclaimable 3 <code>DB_MEM_ACPI_NVS</code> ACPI Non-Volatile Storage 4 <code>DB_MEM_BAD</code> Bad memory, do not use 5 <code>DB_MEM_BOOTLOADER</code> Used by bootloader, reclaimable 6 <code>DB_MEM_KERNEL</code> Kernel image 7 <code>DB_MEM_FRAMEBUFFER</code> Framebuffer memory 8 <code>DB_MEM_INITRD</code> Initial ramdisk, reclaimable 9 <code>DB_MEM_MODULES</code> Loaded modules"},{"location":"boot/protocol/#db_tag_framebuffer-0x0003","title":"DB_TAG_FRAMEBUFFER (0x0003)","text":"<p>Framebuffer information for graphical output.</p> <pre><code>struct db_tag_framebuffer {\n    u16 type;           // 0x0003\n    u16 flags;          // 0\n    u32 size;           // Tag size\n    u64 address;        // Physical address of framebuffer\n    u32 width;          // Width in pixels\n    u32 height;         // Height in pixels\n    u32 pitch;          // Bytes per scanline\n    u8  bpp;            // Bits per pixel\n    u8  red_shift;      // Red component bit position\n    u8  red_size;       // Red component bit size\n    u8  green_shift;\n    u8  green_size;\n    u8  blue_shift;\n    u8  blue_size;\n    u8  reserved_shift;\n    u8  reserved_size;\n    u8  padding[3];     // Alignment padding\n};\n</code></pre>"},{"location":"boot/protocol/#db_tag_modules-0x0004","title":"DB_TAG_MODULES (0x0004)","text":"<p>Loaded boot modules (initramfs, drivers, etc.).</p> <pre><code>struct db_tag_modules {\n    u16 type;           // 0x0004\n    u16 flags;          // 0\n    u32 size;           // Total tag size\n    u32 module_count;   // Number of modules\n    u32 reserved;\n    struct db_module modules[];\n};\n\nstruct db_module {\n    u64 start;          // Physical start address\n    u64 end;            // Physical end address (exclusive)\n    u32 name_offset;    // Offset to null-terminated name string (from tag start)\n    u32 cmdline_offset; // Offset to null-terminated cmdline (from tag start)\n};\n// Module names and cmdlines stored as strings after the module array\n</code></pre>"},{"location":"boot/protocol/#db_tag_initrd-0x000b","title":"DB_TAG_INITRD (0x000B)","text":"<p>Initial ramdisk (initrd or initramfs)  This is the primary way to load a initial filesystem for early boot.</p> <pre><code>struct db_tag_initrd {\n    u16 type;           // 0x000B\n    u16 flags;          // 0\n    u32 size;           // Tag size\n    u64 start;          // Physical start address of initrd\n    u64 length;         // Size in bytes\n};\n</code></pre> <p>Notes: - The bootloader loads the initrd file into contiguous physical memory - The kernel is responsible for parsing the format (cpio, ext2, etc.) - Memory region is marked as <code>DB_MEM_INITRD</code> in the memory map (reclaimable after use)</p>"},{"location":"boot/protocol/#db_tag_acpi_rsdp-0x0005","title":"DB_TAG_ACPI_RSDP (0x0005)","text":"<p>ACPI Root System Description Pointer.</p> <pre><code>struct db_tag_acpi_rsdp {\n    u16 type;           // 0x0005\n    u16 flags;          // Bit 0: set if XSDP (ACPI 2.0+)\n    u32 size;           // Tag size\n    u64 rsdp_address;   // Physical address of RSDP/XSDP\n};\n</code></pre>"},{"location":"boot/protocol/#db_tag_smp-0x0006","title":"DB_TAG_SMP (0x0006)","text":"<p>Symmetric Multi Processing information.</p> <pre><code>struct db_tag_smp {\n    u16 type;           // 0x0006\n    u16 flags;          // 0\n    u32 size;           // Tag size\n    u32 cpu_count;      // Number of CPUs\n    u32 bsp_id;         // Bootstrap processor ID\n    struct db_cpu cpus[];\n};\n\nstruct db_cpu {\n    u32 id;             // CPU/APIC ID (arch-specific)\n    u32 flags;          // Bit 0: enabled, Bit 1: is BSP\n};\n</code></pre>"},{"location":"boot/protocol/#db_tag_bootloader-0x0008","title":"DB_TAG_BOOTLOADER (0x0008)","text":"<p>Bootloader identification.</p> <pre><code>struct db_tag_bootloader {\n    u16 type;           // 0x0008\n    u16 flags;          // 0\n    u32 size;           // Tag size\n    char name[];        // Null-terminated bootloader name/version\n};\n</code></pre>"},{"location":"boot/protocol/#minimal-kernel-example-pseudocode","title":"Minimal Kernel Example (Pseudocode)","text":"<pre><code>// Entry point receives db_boot_info pointer\nvoid kernel_main(struct db_boot_info* info) {\n    // Verify magic\n    if (info-&gt;magic != 0x44424F4B) {\n        panic(\"Not booted via DB protocol\");\n    }\n\n    // Iterate tags\n    struct db_tag* tag = (void*)info + sizeof(*info);\n\n    while (tag-&gt;type != DB_TAG_END) {\n        switch (tag-&gt;type) {\n            case DB_TAG_MEMORY_MAP:\n                parse_memory_map((struct db_tag_memory_map*)tag);\n                break;\n            case DB_TAG_FRAMEBUFFER:\n                init_framebuffer((struct db_tag_framebuffer*)tag);\n                break;\n            //... handle other tags\n        }\n\n        // Advance to next tag (8-byte aligned)\n        tag = (void*)tag + ((tag-&gt;size + 7) &amp; ~7);\n    }\n}\n</code></pre>"},{"location":"boot/protocol/#bootloader-requirements","title":"Bootloader Requirements","text":"<p>A DB-compliant bootloader must:</p> <ol> <li>Locate the DB Request Header in the kernel binary (first 32 KiB, 8-byte aligned)</li> <li>Verify the magic (<code>0x44420001</code>)</li> <li>Load the kernel into memory at an appropriate address (bootloader's choice)</li> <li>Prepare DB Boot Info with requested tags based on request flags</li> <li>Set up machine state:</li> <li>Interrupts disabled</li> <li>Paging enabled with identity mapping (virtual = physical)</li> <li>A20 line enabled (if x86)</li> <li>Pass boot info pointer in the architecture-defined register</li> <li>Jump to kernel entry point</li> </ol>"},{"location":"boot/protocol/#load-address","title":"Load Address","text":"<p>The bootloader chooses where to load the kernel in physical memory. The kernel must be position-independent or linked to expect this. The kernel can determine its load address from the memory map (look for <code>DB_MEM_KERNEL</code> regions).</p>"},{"location":"learning/c_for_kernel/","title":"C Programming Guide for Kernel Development","text":"<p>A companion guide for DeltaOS team members who are new to C programming.</p>"},{"location":"learning/c_for_kernel/#table-of-contents","title":"Table of Contents","text":"<ol> <li>What is C?</li> <li>C Syntax Basics</li> <li>Variables and Types</li> <li>Pointers</li> <li>Functions</li> <li>Control Flow</li> <li>Structures</li> <li>The Preprocessor</li> <li>Reading Kernel Code</li> <li>Common Patterns</li> </ol>"},{"location":"learning/c_for_kernel/#what-is-c","title":"What is C?","text":"<p>C is a programming language created in 1972 that remains the dominant language for operating system development. Nearly every major OS kernel (Linux, Windows, macOS, *BSD) is written primarily in C.</p>"},{"location":"learning/c_for_kernel/#why-c-for-kernels","title":"Why C for Kernels?","text":"<ol> <li>Direct Hardware Access: C can manipulate memory addresses and hardware registers directly</li> <li>No Runtime Dependencies: C code doesn't need any external libraries to run</li> <li>Predictable Performance: You know exactly what the CPU will do</li> <li>Close to the Metal: The language maps almost directly to machine instructions</li> </ol>"},{"location":"learning/c_for_kernel/#c-vs-other-languages","title":"C vs Other Languages","text":"Feature C Python JavaScript Compiled/Interpreted Compiled Interpreted Interpreted Memory Management Manual Automatic Automatic Type System Static Dynamic Dynamic Runs without OS Yes No No"},{"location":"learning/c_for_kernel/#c-syntax-basics","title":"C Syntax Basics","text":""},{"location":"learning/c_for_kernel/#comments","title":"Comments","text":"<p>Comments are notes for humans that the compiler ignores:</p> <pre><code>// This is a single-line comment\n\n/*\n * This is a multi-line comment.\n * We use these extensively in DeltaOS.\n */\n</code></pre>"},{"location":"learning/c_for_kernel/#statements-and-semicolons","title":"Statements and Semicolons","text":"<p>Every statement in C ends with a semicolon:</p> <pre><code>int x = 5;          // Declare and assign a variable\nx = x + 1;          // Modify the variable\nconsole_puts(\"Hi\"); // Call a function\n</code></pre>"},{"location":"learning/c_for_kernel/#blocks-and-braces","title":"Blocks and Braces","text":"<p>Curly braces <code>{ }</code> group multiple statements:</p> <pre><code>if (condition) {\n    statement1;\n    statement2;\n    statement3;\n}\n</code></pre>"},{"location":"learning/c_for_kernel/#variables-and-types","title":"Variables and Types","text":""},{"location":"learning/c_for_kernel/#what-is-a-variable","title":"What is a Variable?","text":"<p>A variable is a named storage location in memory. In C, every variable has: - A name (how you refer to it) - A type (what kind of data it holds) - A value (the data itself)</p>"},{"location":"learning/c_for_kernel/#basic-types","title":"Basic Types","text":"<p>In DeltaOS, we use custom types defined in <code>types.h</code>:</p> Type Size Description Example Values <code>u8</code> 1 byte Unsigned 8-bit 0 to 255 <code>u16</code> 2 bytes Unsigned 16-bit 0 to 65,535 <code>u32</code> 4 bytes Unsigned 32-bit 0 to ~4 billion <code>u64</code> 8 bytes Unsigned 64-bit 0 to ~18 quintillion <code>i32</code> 4 bytes Signed 32-bit -2 billion to +2 billion <code>bool</code> 1 byte True or false <code>true</code> or <code>false</code>"},{"location":"learning/c_for_kernel/#declaring-variables","title":"Declaring Variables","text":"<pre><code>// Syntax: type name;\nu32 counter;           // Declare a 32-bit unsigned integer\nbool is_ready;         // Declare a boolean\n\n// Syntax: type name = initial_value;\nu32 counter = 0;       // Declare and initialize to 0\nbool is_ready = false; // Declare and initialize to false\n</code></pre>"},{"location":"learning/c_for_kernel/#why-types-matter","title":"Why Types Matter","text":"<p>In C, the type determines: 1. How much memory the variable uses 2. What operations are valid 3. How the data is interpreted</p> <pre><code>u8 small = 255;   // Maximum value for u8\nsmall = small + 1; // OVERFLOW! Wraps to 0, not 256\n</code></pre>"},{"location":"learning/c_for_kernel/#pointers","title":"Pointers","text":"<p>This is the most important concept in C!</p>"},{"location":"learning/c_for_kernel/#what-is-a-pointer","title":"What is a Pointer?","text":"<p>A pointer is a variable that holds a memory address instead of a regular value.</p> <p>Think of memory like a giant array of numbered boxes:</p> <pre><code>Memory:\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 ... \u2502 42  \u2502 ... \u2502 ... \u2502 ... \u2502 ... \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2191\n     Address 0x1000\n</code></pre> <p>A pointer is a variable that stores the address (0x1000), not the value (42).</p>"},{"location":"learning/c_for_kernel/#pointer-syntax","title":"Pointer Syntax","text":"<pre><code>// The * in a declaration means \"pointer to\"\nu32 *ptr;              // ptr is a \"pointer to u32\"\n\n// The &amp; operator gets the address of a variable\nu32 value = 42;\nptr = &amp;value;          // ptr now holds the address of 'value'\n\n// The * operator follows a pointer to its value (dereference)\nu32 copy = *ptr;       // copy is now 42 (the value at the address)\n</code></pre>"},{"location":"learning/c_for_kernel/#visual-example","title":"Visual Example","text":"<pre><code>u32 value = 42;     // Create variable 'value' with value 42\nu32 *ptr = &amp;value;  // Create pointer 'ptr' pointing to 'value'\n\n// Memory now looks like:\n// \n// Address:    0x1000         0x2000\n//            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n// Value:     \u2502   42  \u2502      \u2502 0x1000\u2502\n//            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n//               \u2191              \u2502\n//            'value'        'ptr' (points to value)\n</code></pre>"},{"location":"learning/c_for_kernel/#why-pointers","title":"Why Pointers?","text":"<ol> <li>Efficiency: Pass large data without copying</li> <li>Modification: Functions can modify caller's variables</li> <li>Dynamic Data: Build linked structures</li> <li>Hardware: Access specific memory addresses</li> </ol>"},{"location":"learning/c_for_kernel/#null-pointers","title":"NULL Pointers","text":"<p>A pointer that doesn't point anywhere valid is <code>NULL</code>:</p> <pre><code>u32 *ptr = NULL;   // ptr points to nothing\n\n// ALWAYS check before using!\nif (ptr != NULL) {\n    u32 value = *ptr;  // Safe to dereference\n}\n</code></pre>"},{"location":"learning/c_for_kernel/#functions","title":"Functions","text":""},{"location":"learning/c_for_kernel/#what-is-a-function","title":"What is a Function?","text":"<p>A function is a reusable block of code that: 1. Has a name 2. May take inputs (parameters) 3. May return an output</p>"},{"location":"learning/c_for_kernel/#function-syntax","title":"Function Syntax","text":"<pre><code>// Syntax: return_type function_name(parameter_type parameter_name, ...)\n\n// Function that takes no parameters and returns nothing\nvoid say_hello(void) {\n    console_puts(\"Hello!\\n\");\n}\n\n// Function that takes parameters and returns a value\nu32 add(u32 a, u32 b) {\n    return a + b;\n}\n\n// Function that modifies a value through a pointer\nvoid increment(u32 *value) {\n    *value = *value + 1;\n}\n</code></pre>"},{"location":"learning/c_for_kernel/#calling-functions","title":"Calling Functions","text":"<pre><code>say_hello();              // Call with no arguments\n\nu32 result = add(5, 3);   // Call with arguments, store result\n\nu32 x = 10;\nincrement(&amp;x);            // Pass address of x\n// x is now 11\n</code></pre>"},{"location":"learning/c_for_kernel/#void","title":"void","text":"<p>The keyword <code>void</code> means \"nothing\": - <code>void</code> return type: Function doesn't return anything - <code>void</code> parameter: Function takes no parameters - <code>void *</code>: A pointer to \"anything\" (generic pointer)</p>"},{"location":"learning/c_for_kernel/#control-flow","title":"Control Flow","text":""},{"location":"learning/c_for_kernel/#ifelse-statements","title":"if/else Statements","text":"<pre><code>if (condition) {\n    // Executed if condition is true\n} else if (other_condition) {\n    // Executed if first was false, this is true\n} else {\n    // Executed if all conditions were false\n}\n</code></pre>"},{"location":"learning/c_for_kernel/#comparisons","title":"Comparisons","text":"Operator Meaning <code>==</code> Equal to <code>!=</code> Not equal to <code>&lt;</code> Less than <code>&gt;</code> Greater than <code>&lt;=</code> Less than or equal <code>&gt;=</code> Greater than or equal"},{"location":"learning/c_for_kernel/#logical-operators","title":"Logical Operators","text":"Operator Meaning <code>&amp;&amp;</code> AND (both must be true) <code>||</code> OR (at least one must be true) <code>!</code> NOT (inverts true/false)"},{"location":"learning/c_for_kernel/#while-loops","title":"while Loops","text":"<pre><code>while (condition) {\n    // Repeat while condition is true\n}\n\n// Example: Count from 0 to 9\nu32 i = 0;\nwhile (i &lt; 10) {\n    console_put_dec(i);\n    i = i + 1;\n}\n</code></pre>"},{"location":"learning/c_for_kernel/#for-loops","title":"for Loops","text":"<pre><code>for (initialization; condition; update) {\n    // Repeat while condition is true\n}\n\n// Example: Count from 0 to 9\nfor (u32 i = 0; i &lt; 10; i++) {\n    console_put_dec(i);\n}\n</code></pre>"},{"location":"learning/c_for_kernel/#switch-statements","title":"switch Statements","text":"<pre><code>switch (value) {\ncase 1:\n    // Do something for value == 1\n    break;\ncase 2:\n    // Do something for value == 2\n    break;\ndefault:\n    // Do something for any other value\n    break;\n}\n</code></pre>"},{"location":"learning/c_for_kernel/#structures","title":"Structures","text":""},{"location":"learning/c_for_kernel/#what-is-a-structure","title":"What is a Structure?","text":"<p>A structure groups related variables together into a single unit.</p>"},{"location":"learning/c_for_kernel/#defining-structures","title":"Defining Structures","text":"<pre><code>// Define a structure type\nstruct point {\n    u32 x;\n    u32 y;\n};\n\n// Create a variable of this type\nstruct point origin;\norigin.x = 0;\norigin.y = 0;\n\n// Or initialize at declaration\nstruct point cursor = { .x = 100, .y = 200 };\n</code></pre>"},{"location":"learning/c_for_kernel/#accessing-members","title":"Accessing Members","text":"<p>Use the <code>.</code> operator for regular structures: <pre><code>struct point p;\np.x = 10;\nu32 x_value = p.x;\n</code></pre></p> <p>Use the <code>-&gt;</code> operator for pointers to structures: <pre><code>struct point *ptr = &amp;p;\nptr-&gt;x = 10;        // Same as (*ptr).x = 10\nu32 x_value = ptr-&gt;x;\n</code></pre></p>"},{"location":"learning/c_for_kernel/#typedef","title":"typedef","text":"<p>The <code>typedef</code> keyword creates a shorter name:</p> <pre><code>// Without typedef:\nstruct db_boot_info info;\n\n// With typedef:\ntypedef struct db_boot_info db_boot_info_t;\ndb_boot_info_t info;  // Same thing, shorter name\n</code></pre>"},{"location":"learning/c_for_kernel/#the-preprocessor","title":"The Preprocessor","text":"<p>The preprocessor runs before the C compiler and handles lines starting with <code>#</code>.</p>"},{"location":"learning/c_for_kernel/#include","title":"#include","text":"<p>Copies the contents of another file:</p> <pre><code>#include \"types.h\"       // Include our types.h file\n#include \"boot_info.h\"   // Include boot_info.h file\n</code></pre>"},{"location":"learning/c_for_kernel/#define","title":"#define","text":"<p>Creates a text replacement (macro):</p> <pre><code>#define PAGE_SIZE 4096      // Replace PAGE_SIZE with 4096\n#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))  // Function-like macro\n\nu32 size = PAGE_SIZE;       // Becomes: u32 size = 4096;\nu32 bigger = MAX(x, y);     // Becomes: u32 bigger = ((x) &gt; (y) ? (x) : (y));\n</code></pre>"},{"location":"learning/c_for_kernel/#ifdef-ifndef","title":"#ifdef / #ifndef","text":"<p>Conditional compilation:</p> <pre><code>#ifndef TYPES_H    // If TYPES_H is NOT defined...\n#define TYPES_H    // Define it\n\n// ... file contents ...\n\n#endif             // End the conditional\n</code></pre> <p>This pattern (called an \"include guard\") prevents a file from being included twice.</p>"},{"location":"learning/c_for_kernel/#reading-kernel-code","title":"Reading Kernel Code","text":""},{"location":"learning/c_for_kernel/#code-organization","title":"Code Organization","text":"<p>DeltaOS kernel code follows these conventions:</p> <ol> <li>Files in pairs: <code>foo.h</code> (declarations) and <code>foo.c</code> (implementations)</li> <li>Header files (<code>.h</code>): Tell you what is available</li> <li>Source files (<code>.c</code>): Show how it works</li> </ol>"},{"location":"learning/c_for_kernel/#finding-your-way","title":"Finding Your Way","text":"<pre><code>kernel/\n\u251c\u2500\u2500 types.h       &lt;- Basic types (start here!)\n\u251c\u2500\u2500 boot_info.h   &lt;- Boot protocol structures\n\u251c\u2500\u2500 boot_info.c   &lt;- Boot info parsing\n\u251c\u2500\u2500 console.h     &lt;- Console output interface\n\u251c\u2500\u2500 console.c     &lt;- Console implementation\n\u251c\u2500\u2500 panic.h       &lt;- Panic interface\n\u251c\u2500\u2500 panic.c       &lt;- Panic implementation\n\u2514\u2500\u2500 main.c        &lt;- Kernel entry point\n</code></pre>"},{"location":"learning/c_for_kernel/#reading-a-function","title":"Reading a Function","text":"<p>When reading a function, look for:</p> <ol> <li>Doc comment above: Describes purpose, parameters, return value</li> <li>Function signature: Name, parameters, return type</li> <li>Security comments: Lines marked <code>// SECURITY:</code></li> <li>Step comments: Major steps are labeled</li> </ol> <p>Example from our code: <pre><code>/*\n * boot_info_validate - Check if boot info is valid\n * \n * Parameters:\n *   info - Pointer to the boot info structure\n * \n * Returns:\n *   true if valid, false otherwise\n */\nbool boot_info_validate(const struct db_boot_info *info) {\n    // Check 1: NULL pointer check\n    if (info == NULL) {\n        return false;\n    }\n    // ... more checks ...\n}\n</code></pre></p>"},{"location":"learning/c_for_kernel/#common-patterns","title":"Common Patterns","text":""},{"location":"learning/c_for_kernel/#error-checking","title":"Error Checking","text":"<p>Always check for errors before proceeding:</p> <pre><code>if (!boot_info_validate(boot_info)) {\n    panic(\"Invalid boot info!\");\n}\n</code></pre>"},{"location":"learning/c_for_kernel/#iterating-through-arrays","title":"Iterating Through Arrays","text":"<pre><code>for (u32 i = 0; i &lt; count; i++) {\n    // Process array[i]\n}\n</code></pre>"},{"location":"learning/c_for_kernel/#iterating-through-linked-data","title":"Iterating Through Linked Data","text":"<pre><code>const struct db_tag *tag = NULL;\nwhile ((tag = boot_info_get_next_tag(info, tag)) != NULL) {\n    // Process tag\n}\n</code></pre>"},{"location":"learning/c_for_kernel/#bit-manipulation","title":"Bit Manipulation","text":"<pre><code>// Check if a bit is set\nif (flags &amp; (1 &lt;&lt; bit_number)) {\n    // Bit is set\n}\n\n// Set a bit\nflags = flags | (1 &lt;&lt; bit_number);\n\n// Clear a bit\nflags = flags &amp; ~(1 &lt;&lt; bit_number);\n</code></pre>"},{"location":"learning/c_for_kernel/#safe-pointer-usage","title":"Safe Pointer Usage","text":"<pre><code>// Always check before dereferencing\nif (ptr != NULL) {\n    value = *ptr;\n}\n\n// Initialize pointers to NULL\nu8 *buffer = NULL;\n\n// Set to NULL after freeing\nfree(buffer);\nbuffer = NULL;\n</code></pre>"},{"location":"learning/c_for_kernel/#next-steps","title":"Next Steps","text":"<p>After reading this guide:</p> <ol> <li>Read <code>kernel/types.h</code> - it's heavily commented</li> <li>Read <code>kernel/main.c</code> - follow the boot sequence</li> <li>Look at <code>kernel/console.c</code> - see a complete subsystem</li> <li>Try making small changes and rebuilding</li> </ol> <p>Remember: Ask questions! The best way to learn is to be curious.</p> <p>This guide is part of the DeltaOS Documentation. Team Decision: Basic C concepts explained here, advanced concepts in code comments.</p>"},{"location":"learning/security/","title":"Security Considerations for DeltaOS Kernel","text":"<p>A guide to understanding and maintaining security in the DeltaOS kernel.</p>"},{"location":"learning/security/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Why Security Matters</li> <li>Security Principles</li> <li>Common Vulnerabilities</li> <li>Defensive Coding Practices</li> <li>Security Markers in Code</li> <li>Future Security Features</li> </ol>"},{"location":"learning/security/#why-security-matters","title":"Why Security Matters","text":"<p>The kernel is the most privileged code in the system. It has: - Full access to all memory - Control over all hardware - Authority over all processes</p> <p>A security flaw in the kernel means: - Complete system compromise: Attackers gain full control - No recovery: There's no higher authority to fix things - Data exposure: All user data becomes accessible</p> <p>This is why we treat security as a first-class concern in DeltaOS.</p>"},{"location":"learning/security/#security-principles","title":"Security Principles","text":""},{"location":"learning/security/#1-defense-in-depth","title":"1. Defense in Depth","text":"<p>Never rely on a single security check. Layer multiple protections:</p> <pre><code>// Multiple validation layers\nif (boot_info == NULL) return false;           // Layer 1: NULL check\nif (boot_info-&gt;magic != EXPECTED_MAGIC) ...    // Layer 2: Magic check\nif (boot_info-&gt;size &gt; MAX_SIZE) ...            // Layer 3: Size check\n</code></pre>"},{"location":"learning/security/#2-fail-secure","title":"2. Fail Secure","text":"<p>When in doubt, stop. Don't try to \"work around\" problems:</p> <pre><code>// WRONG: Try to continue despite error\nif (result == ERROR) {\n    result = 0;  // \"Fix\" the error and continue\n}\n\n// RIGHT: Stop when something is wrong\nif (result == ERROR) {\n    panic(\"Critical error: cannot continue safely\");\n}\n</code></pre>"},{"location":"learning/security/#3-least-privilege","title":"3. Least Privilege","text":"<p>Give code only the access it needs, no more:</p> <ul> <li>Memory pages: Only grant read/write/execute as needed</li> <li>Hardware access: Only enable what's required</li> <li>Capabilities: Future processes get minimal permissions by default</li> </ul>"},{"location":"learning/security/#4-validate-all-inputs","title":"4. Validate All Inputs","text":"<p>Never trust data from external sources. This includes: - Boot information from the bootloader - Data from hardware devices - File system contents - User input</p>"},{"location":"learning/security/#common-vulnerabilities","title":"Common Vulnerabilities","text":""},{"location":"learning/security/#buffer-overflow","title":"Buffer Overflow","text":"<p>What: Writing beyond the end of a buffer, corrupting adjacent memory.</p> <p>Example Attack: <pre><code>// VULNERABLE:\nchar buffer[10];\nstrcpy(buffer, user_input);  // If user_input &gt; 10 chars, overflow!\n</code></pre></p> <p>Prevention in DeltaOS: - Always track buffer sizes - Use bounds-checked operations - Validate sizes before copying</p> <pre><code>// SAFE:\nif (length &gt; buffer_size) {\n    return ERROR_TOO_LARGE;\n}\nfor (u32 i = 0; i &lt; length; i++) {\n    buffer[i] = source[i];\n}\n</code></pre>"},{"location":"learning/security/#integer-overflow","title":"Integer Overflow","text":"<p>What: Arithmetic that wraps around due to fixed-size integers.</p> <p>Example Attack: <pre><code>// VULNERABLE:\nu32 total_size = count * element_size;  // Can overflow!\nu8 *buffer = allocate(total_size);      // Allocates tiny buffer\ncopy_into(buffer, count * element_size); // Overflows!\n</code></pre></p> <p>Prevention in DeltaOS: <pre><code>// SAFE: Check before arithmetic\nif (count &gt; U32_MAX / element_size) {\n    return ERROR_OVERFLOW;\n}\nu32 total_size = count * element_size;\n</code></pre></p>"},{"location":"learning/security/#null-pointer-dereference","title":"Null Pointer Dereference","text":"<p>What: Following a pointer that doesn't point to valid memory.</p> <p>Prevention: <pre><code>// Always check before use\nif (ptr == NULL) {\n    return ERROR_NULL_POINTER;\n}\nvalue = *ptr;  // Now safe\n</code></pre></p>"},{"location":"learning/security/#use-after-free","title":"Use After Free","text":"<p>What: Using memory after it's been freed.</p> <p>Prevention: <pre><code>free(buffer);\nbuffer = NULL;  // Set to NULL immediately\n// Any future use with NULL check will fail safely\n</code></pre></p>"},{"location":"learning/security/#missing-bounds-check","title":"Missing Bounds Check","text":"<p>What: Accessing arrays without verifying the index is valid.</p> <p>Prevention: <pre><code>// ALWAYS check array bounds\nif (index &gt;= array_size) {\n    return ERROR_OUT_OF_BOUNDS;\n}\nvalue = array[index];\n</code></pre></p>"},{"location":"learning/security/#defensive-coding-practices","title":"Defensive Coding Practices","text":""},{"location":"learning/security/#1-initialize-everything","title":"1. Initialize Everything","text":"<p>Uninitialized variables can contain dangerous garbage values:</p> <pre><code>// DANGEROUS:\nu32 flags;\nif (flags &amp; SOMETHING) {  // flags is garbage!\n    ...\n}\n\n// SAFE:\nu32 flags = 0;\n</code></pre>"},{"location":"learning/security/#2-use-safe-types","title":"2. Use Safe Types","text":"<p>Our <code>types.h</code> provides fixed-width types that prevent surprises:</p> <pre><code>// Instead of:\nint count;      // Could be 16, 32, or 64 bits!\n\n// Use:\nu32 count;      // Always exactly 32 bits\n</code></pre>"},{"location":"learning/security/#3-document-security-decisions","title":"3. Document Security Decisions","text":"<p>Mark security-critical code with comments:</p> <pre><code>// SECURITY: This check prevents buffer overflow\nif (size &gt; MAX_ALLOWED_SIZE) {\n    return ERROR;\n}\n</code></pre>"},{"location":"learning/security/#4-avoid-dangerous-patterns","title":"4. Avoid Dangerous Patterns","text":"Avoid Use Instead Raw pointer arithmetic Bounds-checked access Unchecked casts Explicit validation Magic numbers Named constants Implicit fallthrough Explicit break statements"},{"location":"learning/security/#5-test-edge-cases","title":"5. Test Edge Cases","text":"<p>Security bugs often hide in edge cases: - Empty inputs (size = 0) - Maximum values (SIZE_MAX) - Boundary conditions (off-by-one) - Malformed data</p>"},{"location":"learning/security/#security-markers-in-code","title":"Security Markers in Code","text":"<p>Throughout DeltaOS code, look for these comment markers:</p>"},{"location":"learning/security/#security","title":"SECURITY:","text":"<p>Marks a line or block that's specifically for security:</p> <pre><code>// SECURITY: Validate magic before trusting any other fields\nif (info-&gt;magic != EXPECTED_MAGIC) {\n    return false;\n}\n</code></pre>"},{"location":"learning/security/#security-warning","title":"SECURITY WARNING:","text":"<p>Calls attention to potentially dangerous code that must be used carefully:</p> <pre><code>// SECURITY WARNING: This function has no bounds checking!\n// Caller must ensure buffer is large enough.\nvoid unsafe_copy(void *dest, void *src, u32 size);\n</code></pre>"},{"location":"learning/security/#todo-security","title":"TODO SECURITY:","text":"<p>Marks security improvements that should be made:</p> <pre><code>// TODO SECURITY: Add stack canary checking here\n</code></pre>"},{"location":"learning/security/#future-security-features","title":"Future Security Features","text":""},{"location":"learning/security/#already-implemented","title":"Already Implemented","text":"<ul> <li>\u2705 Input validation on boot info</li> <li>\u2705 Bounds checking on array access</li> <li>\u2705 Integer overflow prevention</li> <li>\u2705 Defensive initialization</li> </ul>"},{"location":"learning/security/#planned-for-implementation","title":"Planned for Implementation","text":""},{"location":"learning/security/#memory-protection","title":"Memory Protection","text":"<ol> <li>NX (No-Execute) Bit: Prevent code execution in data pages</li> <li>Write-XOR-Execute: Pages are either writable OR executable, never both</li> <li>Guard Pages: Unmapped pages between allocations to catch overflows</li> <li>ASLR (Address Space Layout Randomization): Randomize memory locations</li> </ol>"},{"location":"learning/security/#runtime-protection","title":"Runtime Protection","text":"<ol> <li>Stack Canaries: Detect stack buffer overflows</li> <li>KASLR: Randomize kernel load address</li> <li>SMEP/SMAP: Prevent kernel from executing/accessing user memory</li> </ol>"},{"location":"learning/security/#access-control","title":"Access Control","text":"<ol> <li>Capability System: Fine-grained permission control</li> <li>Sandboxing: Isolate processes from each other</li> <li>Secure Boot: Verify kernel integrity before execution</li> </ol>"},{"location":"learning/security/#security-checklist-for-new-code","title":"Security Checklist for New Code","text":"<p>Before submitting new code, verify:</p> <ul> <li>[ ] All pointers checked for NULL before dereference</li> <li>[ ] All array accesses bounds-checked</li> <li>[ ] All arithmetic checked for overflow where size is involved</li> <li>[ ] All input from external sources validated</li> <li>[ ] All security decisions documented with comments</li> <li>[ ] Error cases handled by failing safely</li> <li>[ ] Variables initialized to safe default values</li> <li>[ ] Code compiles without warnings (<code>-Wall -Wextra -Werror</code>)</li> </ul>"},{"location":"learning/security/#team-decision-log","title":"Team Decision Log","text":"Date Decision Rationale Initial snake_case naming Standard in kernel code, improves readability Initial Treatment of warnings as errors Catches potential security issues early Initial Comprehensive input validation Defense in depth protects against bootloader bugs <p>This document is part of the DeltaOS Documentation. Security is everyone's responsibility.</p>"}]}